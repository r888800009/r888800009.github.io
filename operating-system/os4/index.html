<!DOCTYPE html>
<html>
    <head>
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-19124306-5', 'auto');
	
	ga('send', 'pageview');
}
</script>

<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0" />
<meta name="theme-color" content="#000000">
<link rel="icon" type="image/png" href="/favicon.png">
<link rel="stylesheet" type="text/css" href="/css/css.css">



<title>[OS] Process | r809&#39;s Notes</title>

<script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML">
</script>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.9/styles/hybrid.min.css">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.10.1/css/all.css" integrity="sha256-fdcFNFiBMrNfWL6OcAGQz6jDgNTRxnrLEd4vJYFWScE=" crossorigin="anonymous">

</head>
    <body><nav id="main-menu">
    
    
    <a href="https://github.com/r888800009" title="">
        <i class="fab fa-github"></i>
        
    </a>
    
    <a href="/portfolio/" title="Portfolio">
        
        Portfolio
    </a>
    
</nav>
<div id="main">    <h1 class="website-name" id="website-name"><a href="https://r888800009.github.io/" class="website-name">[OS] Process</a></h1>
<div id="content"><div class="date"> 
        <time datetime="2020-03-23 10:47:48 &#43;0800 CST">Mon, 2020 Mar 23</time>
    </div> 
    <h2 id="41-process-基本概念">4.1 process 基本概念</h2>
<ul>
<li>程式做I/O時，System Call會產生I/O Process，所以在大部份情況，
程式都有兩個或以上個process。</li>
<li>Passive Entity: 程式</li>
<li>Active Entity: process</li>
<li>Job Step: 可以視為程式，並且內部有2個以上的process</li>
<li>若不細分也可稱為Task: Multitasking =&gt; multiprogramming</li>
<li>平行
<ul>
<li>pseudo Parallelism: 透過單個CPU模擬平行，concurrent</li>
<li>True Parallelism: 多個CPU</li>
</ul>
</li>
</ul>
<h3 id="process-的組成">process 的組成</h3>
<ul>
<li>機器碼</li>
<li>資料</li>
<li>資源: RAM, file..</li>
<li>Stack: 中斷後需要透過stack保存狀態</li>
<li>Status: PC, CPU register, process state</li>
<li>Process ID</li>
</ul>
<p>注: Abstract Machine =&gt; Virtual Machine</p>
<h3 id="狀態">狀態</h3>
<p>當單一CPU時，僅能有一個Process在Processor執行</p>
<ul>
<li>Ready state: 系統包含ready queue處理不同process等待，有0到多個process
<ul>
<li>Dispatch =&gt; queue front的process轉換成Running state</li>
</ul>
</li>
<li>Running state: 只有一個Process可以佔有CPU，有0或1的process
<ul>
<li>Time Out =&gt; 回到 Ready state</li>
<li>I/O Block或Wait Event =&gt; 進入 block state</li>
</ul>
</li>
<li>Blocked state: 放置於 Blocked queue(或array)，有0到多個process
<ul>
<li>Wake Up =&gt; 等待完成後回到 Ready state，並且放到ready queue</li>
</ul>
</li>
</ul>
<h3 id="context-switch">Context Switch</h3>
<p>將CPU切換給另一個Process使用，透過<strong>中斷</strong>處理。</p>
<p>Context Switch發生在當前Process:</p>
<ul>
<li>timeout: 切換入Ready並dispatch process</li>
<li>I/O, Event: 切換入Blocked並dispatch</li>
<li>Terminated: terminate當前process並且dispatch</li>
</ul>
<h4 id="中斷方式">中斷方式</h4>
<ol>
<li>save CPU status與一般中斷相同</li>
<li>執行CPU排程工作</li>
<li>restore CPU status時將<strong>預定process狀態放入CPU</strong></li>
<li>執行process</li>
</ol>
<h3 id="process-control-blcok-pcb">Process control blcok (PCB)</h3>
<p>也稱為Process Descriptor，保存<a href="#process-%E7%9A%84%E7%B5%84%E6%88%90">process的相關內容</a>，
一個資料結構保存Process的資料，<strong>PID為獨一無二</strong>。</p>
<h2 id="42-process-排程">4.2 Process 排程</h2>
<p>CPU Scheduler(Short term scheduler)用於管理ready queue與分派process給CPU</p>
<p>注: fork process時，等待child process terminates才將原process排入ready queue</p>
<h3 id="各種排程器">各種排程器</h3>
<ul>
<li>Long term Scheduler:
將process由disk移入Main memory，進入ready queue，
控制Multiprogramming的程式數量</li>
<li>中程排程器:
將process由Main Memory移入disk中，減少multiprogramming數量。
<ul>
<li>swap out (roll out, page out)</li>
<li>swap in</li>
</ul>
</li>
<li>short term scheduler: 管理佔有CPU被Process佔有的工作</li>
</ul>
<h3 id="io-bound-cpu-bound-process">I/O bound, CPU bound process</h3>
<ul>
<li>I/O bound: I/O 時間 &gt; 計算時間</li>
<li>CPU bound: I/O 時間 &lt; 計算時間</li>
</ul>
<h4 id="情況">情況</h4>
<ul>
<li>all I/O bound: cpu排程器無負荷</li>
<li>all cpu bound: 極為緩慢，用完time slice</li>
</ul>
<h2 id="43-process-operating">4.3 process operating</h2>
<p>shell等待直到輸入，
shell輸入命令後透過fork產生另外一個shell process，
並且新的process會以預計開啟的程式取代當前process的內容。</p>
<h3 id="處理元功能">處理元功能</h3>
<p>System call</p>
<ul>
<li><strong>fork</strong></li>
<li><strong>execve</strong></li>
<li>wait: parent process等待children process全部執行完畢之後，
由block切換到readly</li>
<li>exit: 控制權回到OS</li>
<li>abort: 結束process，並且有<strong>Cascading Termination</strong></li>
</ul>
<h3 id="fork">fork</h3>
<p>process產生新的process，其程式碼與資源相同，
新的process由fork之後繼續執行。</p>
<ul>
<li>parent process: pid != 0</li>
<li>children process: pid = 0</li>
</ul>
<h3 id="execve">execve</h3>
<p>透過預定開啟的程式的process蓋過當前的處理元。</p>
<h2 id="44-合作process">4.4 合作process</h2>
<p>可以<strong>影響</strong>或<strong>被影響</strong>的process之間為cooperating process。</p>
<p>ex: execve產生的process彼此之間為合作process</p>
<ul>
<li>concurrent process: 並行處理元，在time sharing環境process都輪流佔有CPU time slice。</li>
<li>Independent Process: 相對於cooperating process，不受其他process影響的。</li>
</ul>
<h3 id="process-互助的目的">process 互助的目的</h3>
<ul>
<li>information sharing</li>
<li>Computation speedup</li>
<li>Modularity</li>
<li>convenience</li>
</ul>
<p><strong>合作處理元範例</strong></p>
<ul>
<li><strong>pipe</strong>: <code>cat file file2 | sort</code></li>
</ul>
<h3 id="producer-and-consumer">Producer and Consumer</h3>
<p>Producer 與 Consumer的架構， 由於process為非同步因此中間<strong>必須</strong>有buffer，
選兩個process找出當中的關係。</p>
<p>buffer透過ring buffer(circuler buffer)處理</p>
<ul>
<li>producer: 產生資料，若buffer滿的話，必須讓producer wait</li>
<li>consumer: 使用資料，若buffer為空，必須讓consumer wait</li>
</ul>
<p>注: 由於設備有時間差，為了避免完全填滿或空buffer，
透過經驗法則去決定何時wait，如7分滿或3分滿時。</p>

    
      <hr>
      
        <a href="https://r888800009.github.io/tags/operating-system" class="tags">Operating System</a>
      
    
    <script>
      (function addHeadingLinks(){
        var article = document.getElementById('content');
        var headings = article.querySelectorAll('h1, h2, h3, h4, h5, h6');
        headings.forEach(function(heading){
          if(heading.id){
            var a = document.createElement('a');
            a.innerHTML = '#';
            a.className = 'subheader';
            a.href = '#'+heading.id;
            heading.appendChild(a);
          }
        });
      })();
    </script>


            </div>
        </div><footer>
  <hr>
  <div>
    <a href="/tags" class="footer">Tags</a>
    <a href="#website-name" class="footer">Top</a>
  </div>
  <div>
    r888800009©2018-2020.
    All Rights Reserved.
  </div>
</footer>

<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/highlight.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/r.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/haskell.min.js"></script>
<script>
  hljs.initHighlightingOnLoad();
  hljs.registerLanguage("plaintext",function(e){return{disableAutodetect:!0}});
</script>
</body>
</html>
